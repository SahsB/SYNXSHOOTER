<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8" />
    <title>Sync</title>
	<script type="text/javascript" src="https://cdn.jsdelivr.net/phaser/2.4.8/phaser.min.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>

<body>
<script src="/socket.io/socket.io.js"></script>
<script type="text/javascript">

var game = new Phaser.Game(window.innerWidth, window.innerHeight, Phaser.AUTO, '', { preload: preload, create: create, update: update });
var socket = io();

function preload() {

    game.load.image('gamestart', '/assets/gamestart.png');
    game.load.image('sky', '/assets/seatiles.png');
    game.load.image('bullet', '/assets/shump_assets/player_bullet_2.png');
		game.load.image('lb', '/assets/lb.png');
		game.load.image('player', '/assets/THSR.png');
		game.load.image('enemy1', '/assets/EMU800.png');
		game.load.image('enemy2', '/assets/EMU700.png');
		game.load.image('enemy3', '/assets/shump_assets/mob_flagship_1.png');
		game.load.spritesheet('enemy4', '/assets/shump_assets/mob_turret_1.png', 24, 24);
		game.load.image('enemy_bullet1', '/assets/bullet.png');
		game.load.image('enemy_bullet2', '/assets/shump_assets/mob_bullet_2.png');
		game.load.image('square', '/assets/tile_question_box.png');
		game.load.image('ultsign', '/assets/50ult.png');
		game.load.image('ultsign_g', '/assets/50ult_gray.png');

		game.load.spritesheet('bonus_cube', 'assets/shump_assets/cubes.png', 24, 24);
		game.load.spritesheet('explosion', 'assets/shump_assets/explosion_1.png', 32, 32);
    //game.load.spritesheet('dude', '/assets/dude.png', 32, 48);
	//game.load.spritesheet('player_bullet', '/assets/shump_assets/player_bullets.png');
}

var player_bullet_velocity = 750, background_movement = 1;
var enemy_bullet_velocity = 250;

var background;
var player, bullets, lbs;
var enemys = new Array(), enemyBullets = new Array();
var enemy_num = [20, 10, 2, 4], enemyBullet_num = [400, 400];
var lives;
const MAX_LIFE = 3;
var weaponLevel = 0;
const MAX_WEAPON_LEVEL = 4;
var boxes;
const yellow = 0, orange = 1, green = 2, chocolate = 3, blue = 4, dark_blue = 5, gray = 6;
var explosionPool;
const ENEMY_1_HEALTH = 1, ENEMY_2_HEALTH = 3, ENEMY_3_HEALTH = 500, ENEMY_4_HEALTH = 5;
var state = 0;
var score = 0;
var scoreText;
var ultText;
var ult=0;
var ultstate = ['restore','ready'];
var ultsign;
var ultsign_g;
var gameOverText;
var gamestart;
var weaponMode=0;
var fireRate = 100;
var nextFire = 0;

// The following 3 variables is used to make player undead at spawn state to prevent instantaneous death upon spawning.
var playerSpawnUndeadTime = 10000; // in milliseconds
var playerSpawnUndead = false;	//whether player is undead
var tweenPlayer; //the tween effects of player

//var enemyFireRate = 500;
//var enemyNextFire = 0;

//var enemyRate = 1000;
var nextEnemy = 0, nextEnemy2 = 0, nextEnemy3 = 10000, nextEnemy4 = 0;
var nextBox = 0;

function create() {
	setupBackground();
	setupPlayer(false);
	setupBullets();
	setupLbs();
	setupEnemys();
	setupEnemyBullets();
	setupPlayerLives();
	setupBoxes();
	setupExplosions();
	setupMenu();
	setupULT();
	scoreText = game.add.text(16, 16, 'score: 0', { fontSize: '20px', fill: '#000' });
	ultText = game.add.text(65, 50, 'ULT state: restore', { fontSize: '20px', fill: '#000' });
}

var newX = 0;
var newY = 0;

function update() {
	//scroll background
	background.tilePosition.y += background_movement;
	enemys[3].forEachAlive(function(enemy)	{
		enemy.position.y += background_movement;
	}, this);

    socket.on('setX', function(data) {
			newX = parseFloat(data);
    });
		socket.on('setY', function(data) {
			newY = parseFloat(data);
	    });
		socket.on('ultra', function(data) {
			if(player.alive)
				launchult();
	    });
		socket.on('start', function(data) {
			state=0;
			if( !player.alive )	{
				setupPlayer(false);
				weaponLevel=0;
				score=0;

				setupBullets();
				setupPlayerLives();
				gameOverText.kill();
			}
			resetMenu();
		});
		socket.on('shoot', function(data) {
			if(state===0){
				game.time.events.add(Phaser.Timer.SECOND * 10, fillult, this);
				state=1;
				gamestart.kill();
				setPlayerSpawnTimeUndead(); // game start

			} else{
				fire();
			}
	  });
		scoreText.text = 'Score: ' + score;
		ultText.text = 'ULT state: ' + ultstate[ult];

    if(state===1){

		player.body.velocity.x = 10*(-newY);
		player.body.velocity.y = 10*(-newX);

		spawn_enemy();
		enemy_fire();

		add_boxes();

		for (var i=0;i<4;i++){
			game.physics.arcade.overlap(bullets, enemys[i], enemyHit, null, this);
			game.physics.arcade.overlap(lbs, enemys[i], lbenemyHit, null, this);
			if( i != 3 )	// player(on sky) cannot touch enemys[3](on land)
				game.physics.arcade.overlap(player, enemys[i], playerHit, null, this);
		}
		for( var i = 0 ; i < 2;  i ++ )	{
			game.physics.arcade.overlap(player, enemyBullets[i], playerHitByBullet, null, this);
		}

		game.physics.arcade.overlap(player, boxes, PlayerVsBox, null, this);
	}
}

function fire() {
	if(weaponMode===0){
		if (player.alive && game.time.now > nextFire && bullets.countDead() > 0){
			nextFire = game.time.now + fireRate;
			var bullet = bullets.getFirstDead();
			bullet.reset(player.x , player.y - 10);
			bullet.body.velocity.y = -player_bullet_velocity;
			if (this.bullets.countDead() < weaponLevel * 2) {
				return;
			}
			for (var i = 1; i <= weaponLevel; i++) {
				bullet = bullets.getFirstExists(false);
				// spawn left bullet slightly left off center
				bullet.reset(player.x - i * 6, player.y - 10);
				// the left bullets spread from -95 degrees to -135 degrees
				game.physics.arcade.velocityFromAngle(
					-95 - i * 10, player_bullet_velocity, bullet.body.velocity
				);

				bullet = bullets.getFirstExists(false);
				// spawn right bullet slightly right off center
				bullet.reset(player.x + i * 6, player.y - 10);
				// the right bullets spread from -85 degrees to -45
				game.physics.arcade.velocityFromAngle(
					-85 + i * 10, player_bullet_velocity, bullet.body.velocity
				);
			}
		}
	}
	else if(weaponMode===1){
		if (player.alive && game.time.now > nextFire && lbs.countDead() > 0){
			nextFire = game.time.now + fireRate;
			var lb = lbs.getFirstDead();
			lb.reset(player.x , player.y - 10);
			lb.body.velocity.y = -player_bullet_velocity*5;
			if (this.lbs.countDead() < weaponLevel * 2) {
				return;
			}
			lb.scale.setTo(1+0.5*weaponLevel,1);
		}
	}
}

function fillult(){
	ult=1;
	ultsign = game.add.sprite(16, 36, 'ultsign');
	ultText.fill='#F00';
}

function launchult(){
	if(ult===1){
		ult=0;
		ultText.fill='#000';
		ultsign.kill();
		enemys[0].forEachAlive(function (enemy) {
			explode(enemy);
			enemy.kill();
			score+=10;
		}, this);
		enemys[1].forEachAlive(function (enemy) {
			explode(enemy);
			enemy.kill();
			score+=10;
		}, this);
		enemys[2].forEachAlive(function (enemy) {
			explode(enemy);
			enemy.damage(100);
			if(!enemy.alive) score+=10;
		}, this);
		enemys[3].forEachAlive(function (enemy) {
			explode(enemy);
			enemy.kill();
			if(!enemy.alive) score+=10;
		}, this);
		enemyBullets[0].forEachAlive(function (bullet) {
			explode(bullet);
			bullet.kill();
		}, this);
		enemyBullets[1].forEachAlive(function (bullet) {
			explode(bullet);
			bullet.kill();
		}, this);
		game.time.events.add(Phaser.Timer.SECOND * 10, fillult, this);
	}
}

function add_boxes()	{
	if( game.time.now > nextBox && boxes.countDead() > 0 )	{
		nextBox = game.time.now + game.rnd.integerInRange(10000, 30000);
		var box = boxes.getFirstExists(false);
		// spawn at a random location top of the screen
		box.reset(game.rnd.integerInRange(20, game.width - 20), 0);
		box.scale.setTo(1.5, 1.5);
		var rnd = game.rnd.integerInRange(0, 6);
		box.animations.add('box', [rnd*3, rnd*3+1, rnd*3+2], 21, true);
		box.play('box', 15, true, false);
		box.type = rnd;
		// also randomize the speed
		game.physics.arcade.velocityFromAngle(
			game.rnd.integerInRange(180, 360), 50, box.body.velocity
		);

		game.time.events.add(Phaser.Timer.SECOND * 120, fadeBox, this, box);
	}
}

function fadeBox(box) {
		box.kill();
}

function spawn_enemy() {
		if (game.time.now > nextEnemy && enemys[0].countDead() > 0) {
        nextEnemy = game.time.now + game.rnd.integerInRange(1000, 3000);
        var enemy = enemys[0].getFirstExists(false);
        // spawn at a random location top of the screen
        enemy.reset(game.rnd.integerInRange(20, game.width - 20), 0, ENEMY_1_HEALTH);
        // also randomize the speed
        enemy.body.velocity.y = game.rnd.integerInRange(30, 60);

				enemy.enemyNextFire = 0;
    }
		if (game.time.now > nextEnemy2 && enemys[1].countDead() > 0) {
        nextEnemy2 = game.time.now + game.rnd.integerInRange(2000, 4000);
        var enemy = enemys[1].getFirstExists(false);
        // spawn at a random location top of the screen
        enemy.reset(game.rnd.integerInRange(20, game.width - 20), 0, ENEMY_2_HEALTH);
				var target = game.rnd.integerInRange(20, game.width - 20);
				enemy.rotation = game.physics.arcade.moveToXY(
				  enemy, target, game.height,
				  game.rnd.integerInRange(40, 80)
				) - Math.PI / 2;

				enemy.enemyNextFire = 0;
    }
		if (game.time.now > nextEnemy3 && enemys[2].countDead() > 0) {
			nextEnemy3 = game.time.now + game.rnd.integerInRange(60000, 120000);
			var enemy = enemys[2].getFirstExists(false);
			// spawn at a random location top of the screen
			enemy.reset(game.rnd.integerInRange(20, game.width - 20), 0, ENEMY_3_HEALTH);
			// also randomize the speed
			enemy.body.velocity.y = game.rnd.integerInRange(10, 20);

			enemy.enemyNextFire = 0;
	  }
		if (game.time.now > nextEnemy4 && enemys[3].countDead() > 0) {
			nextEnemy4 = game.time.now + game.rnd.integerInRange(10000, 10000);
			var enemy = enemys[3].getFirstExists(false);
			// spawn at a random location top of the screen
			enemy.reset(game.rnd.integerInRange(20, game.width - 20), 0, ENEMY_4_HEALTH);

			enemy.enemyNextFire = 0;

			// animationq
			enemy.animations.add('open', [0, 1, 2, 3, 4, 5, 6, 7, 8, 8, 8, 8, 8, 8], 20, false);
			enemy.animations.add('close', [8, ,8 ,8 ,8, 8, 8, 7, 6, 5, 4, 3, 2, 1, 0], 20, false);

			enemy4_attack(enemy);
	  }
}

function enemy4_attack(enemy)	{
	if ( game.time.now > enemy.enemyNextFire && enemyBullets[1].countDead() > 0 && enemy.alive ){
		enemy.enemyNextFire = game.time.now + game.rnd.integerInRange(10000, 10000);
		enemy.play('open');
		for( var i = 0 ; i < 3 ; i ++ )	{
			//  left
			var enemy_bullet = enemyBullets[1].getFirstDead();
			enemy_bullet.reset(enemy.x - i*30, enemy.y );
			enemy_bullet.body.velocity.x = -200;
			// right
			enemy_bullet = enemyBullets[1].getFirstDead();
			enemy_bullet.reset(enemy.x + i*30, enemy.y );
			enemy_bullet.body.velocity.x = 200;
			// bottom
			enemy_bullet = enemyBullets[1].getFirstDead();
			enemy_bullet.reset(enemy.x, enemy.y + i*30);
			enemy_bullet.body.velocity.y = 200;
			// top
			enemy_bullet = enemyBullets[1].getFirstDead();
			enemy_bullet.reset(enemy.x, enemy.y - i*30);
			enemy_bullet.body.velocity.y = -200;
		}
		enemy.play('close');
	}

}

function enemy_fire() {
	enemys[0].forEachAlive(function (enemy) {
		if (game.time.now > enemy.enemyNextFire && enemyBullets[0].countDead() > 0){
			enemy.enemyNextFire = game.time.now + game.rnd.integerInRange(1000, 3000);
			var enemy_bullet = enemyBullets[0].getFirstDead();
			enemy_bullet.reset(enemy.x, enemy.y + enemy.height/2);
			enemy_bullet.body.velocity.y = enemy_bullet_velocity;
		}
	}, this);

	enemys[1].forEachAlive(function (enemy) {
		if (game.time.now > enemy.enemyNextFire && enemyBullets[0].countDead() > 0){
			enemy.enemyNextFire = game.time.now + game.rnd.integerInRange(2000, 5000);
			var enemy_bullet = enemyBullets[0].getFirstDead();
			enemy_bullet.reset(enemy.x, enemy.y + enemy.height/2);
			game.physics.arcade.moveToObject(enemy_bullet, player, enemy_bullet_velocity);
		}
	}, this);

	enemys[2].forEachAlive(function (enemy) {
		if (game.time.now > enemy.enemyNextFire && enemyBullets[1].countDead() > 0){
			enemy.enemyNextFire = game.time.now + game.rnd.integerInRange(5000, 6000);
			for( var i = 0 ; i < 5 ; i ++ )	{
				var enemy_bullet = enemyBullets[1].getFirstDead();
				enemy_bullet.reset(enemy.x + 50, enemy.y + enemy.height/2 + i*30);
				game.physics.arcade.moveToObject(enemy_bullet, player, enemy_bullet_velocity*0.8);

				enemy_bullet = enemyBullets[1].getFirstDead();
				enemy_bullet.reset(enemy.x - 50, enemy.y + enemy.height/2 + i*30);
				game.physics.arcade.moveToObject(enemy_bullet, player, enemy_bullet_velocity*0.8);
			}
		}
	}, this);
}

function enemyHit(bullet, enemy) {
	bullet.kill();
	enemy.damage(1);
	//if (enemy.alive) play hit animation(not available yet) else play explode animation
	explode(enemy);
	score += 10;
}

function lbenemyHit(bullet, enemy) {
	//bullet.kill();
	enemy.damage(1);
	//if (enemy.alive) play hit animation(not available yet) else play explode animation
	explode(enemy);
	score += 10;
}

function playerHit(player, enemy) {
	if (playerSpawnUndead === true) {
		return;
	}
	explode(enemy);
	enemy.kill();
	player.kill();

	var life = lives.getFirstAlive();
    if (life !== null) {
			life.kill();
			explode(player);
			socket.emit('vibrate', 'hit');
			// re alive player
			setupPlayer();
    } else {
			//player.kill();
			explode(player);
			socket.emit('vibrate', 'die');
			gameOver();
    }
}

function playerHitByBullet(player, bullet) {
	if (playerSpawnUndead === true) {
		return;
	}
	bullet.kill();
	player.kill();

	var life = lives.getFirstAlive();
    if (life !== null) {
			life.kill();
			explode(player);
			socket.emit('vibrate', 'hit');
			// re alive player
			setupPlayer();
    } else {
			//player.kill();
			explode(player);
			socket.emit('vibrate', 'die');
			gameOver();
    }
}

function PlayerVsBox(player, box)	{
	//if( box.type === 2 )	{
	switch(box.type)	{
		case yellow:
			break;
		case orange:
			weaponLevel--;
			heal();
			break;
		case green:
			break;
		case chocolate:
			break;
		case blue:
			weaponLevel--;
			swap();
			break;
		case dark_blue:
			break;
		case gray:
			break;
	}
	box.kill();
	score += 50;
	if( weaponLevel < MAX_WEAPON_LEVEL )
		weaponLevel ++;
}

function heal()	{
	var dead_lives = lives.countDead();
	if( dead_lives > 0 ) 	{
		var newlife = lives.getChildAt(dead_lives-1);
		newlife.reset(this.game.width - 10 - (MAX_LIFE * 30) + 30*(dead_lives-1) , 30);
	}
}

function swap(){
	if(weaponMode === 0) weaponMode=1;
	else weaponMode=0;
}

function explode(sprite) {
	if (explosionPool.countDead() === 0) {
		return;
	}
	var explosion = explosionPool.getFirstExists(false);
	explosion.reset(sprite.x, sprite.y);
	explosion.play('boom', 15, false, true);
	// add the original sprite's velocity to the explosion
	explosion.body.velocity.x = sprite.body.velocity.x;
	explosion.body.velocity.y = sprite.body.velocity.y;
}

function gameOver(){
	state=-1;
	gameOverText = game.add.text(game.width/2, game.height / 2, 'Game Over!', { font: '32px sans-serif', fill: '#fff'});
	gameOverText.anchor.setTo(0.5, 0.5);
}

function setupBackground(){
	game.physics.startSystem(Phaser.Physics.ARCADE);
	// Stretch to fill
  //game.scale.fullScreenScaleMode = Phaser.ScaleManager.EXACT_FIT;

	background = game.add.tileSprite(0, 0, window.innerWidth, window.innerHeight, 'sky');
	background.tileScale.x = window.innerWidth/background.width;
	background.tileScale.y = window.innerHeight/background.height;
}

// Parameter: isSetSpawnTimeUndead (default = true): The player will be undead after spawn time for "playerSpawnUndeadTime" milliseconds if this is true
function setupPlayer(isSetSpawnTimeUndead){

	isSetSpawnTimeUndead = typeof isSetSpawnTimeUndead !== 'undefined' ? isSetSpawnTimeUndead : true;

	player = game.add.sprite(game.width / 2, game.height - 50, 'player');
	game.physics.arcade.enable(player);
	player.body.collideWorldBounds = true;
	//game.player.body.setSize(20, 20, 0, -5);
	player.anchor.x = 0.5;
	player.anchor.y = 0.5;
	player.scale.setTo(1.5, 1.5);

	if (isSetSpawnTimeUndead === true)
		setPlayerSpawnTimeUndead();
}

function setPlayerSpawnTimeUndead(){
	//console.log("Now player is created");
	player.alpha = 1;
	playerSpawnUndead = true;
	tweenPlayer = game.add.tween(player).to( { alpha: 0.5 }, 200, Phaser.Easing.Linear.None, true, 0, playerSpawnUndeadTime / (200 * 2), true);
	game.time.events.add(playerSpawnUndeadTime, function(){
		player.alpha = 1;
		tweenPlayer.stop();
		playerSpawnUndead = false;
		//console.log("Now player can be killed");
	}, this);
}

function setupBullets(){
	bullets = game.add.group();
    bullets.enableBody = true;
    bullets.physicsBodyType = Phaser.Physics.ARCADE;

    bullets.createMultiple(1000, 'bullet');
    bullets.setAll('checkWorldBounds', true);
    bullets.setAll('outOfBoundsKill', true);
}

function setupLbs(){
	lbs = game.add.group();
    lbs.enableBody = true;
    lbs.physicsBodyType = Phaser.Physics.ARCADE;

    lbs.createMultiple(1000, 'lb');
    lbs.setAll('checkWorldBounds', true);
	lbs.setAll('outOfBoundsKill', true);
	lbs.setAll('anchor.x', 0.5);
	lbs.setAll('anchor.y', 1);
}

function setupEnemys(){
	for(var i=0;i<4;i++){
		enemys[i] = game.add.group();
		enemys[i].enableBody = true;
		enemys[i].physicsBodyType = Phaser.Physics.ARCADE;

		enemys[i].createMultiple(enemy_num[i], 'enemy'+(i+1));
		enemys[i].setAll('checkWorldBounds', true);
		enemys[i].setAll('outOfBoundsKill', true);
		enemys[i].setAll('anchor.x', 0.5);
		enemys[i].setAll('anchor.y', 0.5);
		enemys[i].setAll('scale.x', (i == 2) ? 3 : 1.5);
		enemys[i].setAll('scale.y', (i == 2) ? 3 : 1.5);

	}
}

function setupEnemyBullets(){
	for( var i = 0 ; i < 2 ; i ++ )	{
		enemyBullets[i] = game.add.group();
		enemyBullets[i].enableBody = true;
		enemyBullets[i].physicsBodyType = Phaser.Physics.ARCADE;

		enemyBullets[i].createMultiple(enemyBullet_num[i], 'enemy_bullet' + (i+1) );
		enemyBullets[i].setAll('checkWorldBounds', true);
		enemyBullets[i].setAll('outOfBoundsKill', true);
		enemyBullets[i].setAll('scale.x', 1.5);
		enemyBullets[i].setAll('scale.y', 1.5);
	}

}

function setupPlayerLives(){
	lives = game.add.group();
	var firstLifeIconX = this.game.width - 10 - (MAX_LIFE * 30);
	for (var i = 0; i < MAX_LIFE; i++) {
		var lifeIcon = this.lives.create(firstLifeIconX + (30 * i), 30, 'player');
		lifeIcon.scale.setTo(0.8, 0.8);
		lifeIcon.anchor.setTo(0.5, 0.5);
	}
}

function setupBoxes() {
	boxes = game.add.group();
	boxes.enableBody = true;
	boxes.physicsBodyType = Phaser.Physics.ARCADE;

	boxes.createMultiple(4, 'bonus_cube');
	boxes.setAll('body.collideWorldBounds', true);
	boxes.setAll('outOfBoundsKill', true);
	boxes.setAll('body.bounce.x', 1);
	boxes.setAll('body.bounce.y', 1);
	/*boxes.forEach(function(box)	{
		box.animations.add('box', [0, 1, 2], 21, true);
	}); */
}

function setupExplosions() {
	explosionPool = game.add.group();
	explosionPool.enableBody = true;
	explosionPool.physicsBodyType = Phaser.Physics.ARCADE;
	explosionPool.createMultiple(100, 'explosion');
	explosionPool.setAll('anchor.x', 0.5);
	explosionPool.setAll('anchor.y', 0.5);
	explosionPool.setAll('scale.x', 1.5);
	explosionPool.setAll('scale.y', 1.5);
	explosionPool.forEach(function (explosion) {
		explosion.animations.add('boom');
	});
}

function setupMenu(){
	gamestart = game.add.sprite(game.width/2, game.height / 2, 'gamestart');
	gamestart.anchor.setTo(0.5, 0.5);
}

function resetMenu(){
	gamestart.reset(game.width/2, game.height / 2);
}

function setupULT(){
	ultsign_g = game.add.sprite(16, 36, 'ultsign_g');
	//ultsign = game.add.sprite(16, 36, 'gamestart');
}

</script>

</body>
</html>
