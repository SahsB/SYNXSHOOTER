<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8" />
    <title>Sync</title>
	<script type="text/javascript" src="https://cdn.jsdelivr.net/phaser/2.4.8/phaser.min.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>

<body>
<script src="/socket.io/socket.io.js"></script>
<script type="text/javascript">

var game = new Phaser.Game(window.innerWidth, window.innerHeight, Phaser.AUTO, '', { preload: preload, create: create, update: update });
var socket = io();

function preload() {
	game.load.image('gamestartMenu', '/assets/menu.png');
	game.load.image('sky', '/assets/seatiles.png');
	game.load.image('bullet', '/assets/shump_assets/player_bullet_2.png');
	game.load.image('ray', '/assets/ray2.png');
	game.load.image('player', '/assets/THSR.png');
	game.load.image('enemy1', '/assets/EMU800.png');
	game.load.image('enemy2', '/assets/EMU700.png');
	game.load.image('enemy3', '/assets/shump_assets/mob_flagship_1.png');
	game.load.image('enemy_bullet1', '/assets/bullet.png');
	game.load.image('enemy_bullet2', '/assets/shump_assets/mob_bullet_2.png');
	game.load.image('square', '/assets/tile_question_box.png');
	game.load.image('ultsign', '/assets/50ult.png');
	game.load.image('ultsign_g', '/assets/50ult_gray.png');
	game.load.image('UFO', '/assets/ufo.png');
	game.load.spritesheet('bonus_cube', 'assets/shump_assets/cubes.png', 24, 24);
	game.load.spritesheet('enemy0', '/assets/shump_assets/mob_turret_1.png', 24, 24);
	game.load.spritesheet('explosion', 'assets/shump_assets/explosion_1.png', 32, 32);
	game.load.spritesheet('shield', 'assets/magic.png', 192, 192);
	game.load.spritesheet('lightning', 'assets/lightning.png', 55, 208);
	game.load.spritesheet('rocket', 'assets/arrows.png', 48, 48);
	game.load.spritesheet('fireball', '/assets/fireball.png', 32, 30);
	this.load.bitmapFont('minecraftia', '/assets/shump_assets/minecraftia.png', '/assets/shump_assets/minecraftia.xml');
}

//Weapon Ult
const BULLET = 0, RAY = 1, LIGHTNING = 2, MAX_WEAPON_LEVEL = 4;
const EMPTY = 0, FILLED = 1; //ULT state
const ULT_FILL_TIME = 10, ULT_DAMAGE = 100;
var bullets, rays, lightnings;
var weaponLevel = 0;
var weaponMode = game.rnd.integerInRange(BULLET,LIGHTNING);
var weapon_num = [500, 20, 10];
var fireRate, rayfireRate, lightningfireRate;
var nextFire = 0;
var player_bullet_velocity = 750;
var ultText, ultsign, ultsign_g;
var ult = EMPTY;
var ultstate = ['restore','ready'];

// Difficulty Score Menu Gameover Gamestate Background
const INGAME = 1, STARTGAME = 0, ENDGAME = -1;
const CHANGING = 1, NOCHANGE = 0;
const LEVELUP_TIME = 25;
var DIFFICULTY = 1;
var DIFFICULTY_CHANGE=NOCHANGE;
var difficultyText;
var levelup_loop;
var score = 0;
var scoreText;
var scoreBoardText;
var gamestartMenu;
var gameOverText;
var state = 0;
var background;
var background_movement = 1;

//Player
const MAX_LIFE = 3, MAX_FIREBALL = 3, MAX_ROCKETS = 20;
const FIREBALL_TIME = 15, FIREBALL_RADIUS = 100;
const ROCKET_COOLDOWN = 3000;
var player, lives;
var playerSpawnUndeadTime = 3000; // in milliseconds
var playerSpawnUndead = false;	//whether player is undead
var tweenPlayer; //the tween effects of player
var shield;
var newX = 0;
var newY = 0;
var rocketPool, rocket_velocity = 800;
var fireballs;
var Ball = new Array();
var fireballEvent = new Array();
var fireballStartTime;
var FireballsExist = false;

// The following 2 variables are the properties of SuperPlayer. (see function superPlayer() below)
var playerSuperTime = 10000;
var playerSuper = false;
var superEvent;
var superTween = new Array();
var tints = [0xff00ff, 0x00ffff, 0x0000ff, 0xff00ff, 0xff0000, 0xffff00];
var tmptint;

//ENEMY
const ENEMY_KINDS = 4, ENEMY_BULLET_KINDS = 2;
const FORT_HEALTH = 5, PLANE_SMALL_HEALTH = 1, PLANE_MEDIUM_HEALTH = 3, PLANE_LARGE_HEALTH = 500;
const FORT = 0, PLANE_SMALL = 1, PLANE_MEDIUM = 2, PLANE_LARGE = 3;
const FORT_BULLET = 1, PLANE_SMALL_BULLET = 0, PLANE_MEDIUM_BULLET = 0, PLANE_LARGE_BULLET = 1;
const FORT_BULLET_NUM = 3; PLANE_LARGE_BULLET_NUM = 5;
var enemys = new Array();
var enemy_num = [4, 20, 10, 2];
var nextEnemy = [0, 0, 0, 10000];
var enemyBullets = new Array();
var enemyBullet_num = [200, 200];
var enemy_bullet_velocity = [200, 350, 250, 200];

// BOSS
const UFO_HEALTH = 500000;
var boss;
var bossBullet;

//Others
const MAX_EXPLOSION = 100;
const MAX_BOXES = 4, BOX_TIME = 120;
const yellow = 0, orange = 1, green = 2, chocolate = 3, blue = 4, dark_blue = 5, gray = 6, colorful = 7;
var boxes;
var nextBox = 0;
var explosionPool;

function create() {
	setupBackground();
	setupEnemys();
	setupEnemyBullets();
	setupPlayer(false);
	setupPlayerLives();
	setupBullets();
	setupRays();
	setupLightnings();
	setupFireRate();
	setupRocket();
	setupFireBalls();
	setupULT();
	setupBoxes();
	setupExplosions();
	setupMenu();
	scoreText = game.add.text(16, 16, 'score: 0', { fontSize: '20px', fill: '#000' });
	ultText = game.add.text(65, 50, 'ULT state: restore', { fontSize: '20px', fill: '#000' });
	listenSocket();
}

function update() {
	background.tilePosition.y += background_movement;
	enemys[FORT].forEachAlive(function(enemy)	{
		enemy.y += background_movement;
	}, this);

	player.body.velocity.x = 10*(-newY);
	player.body.velocity.y = 10*(-newX);

	player.shield.x = player.x;
	player.shield.y = player.y + player.height/2;

	if(state === INGAME && player.alive){

		updateText();

		if(DIFFICULTY_CHANGE === NOCHANGE){
			spawn_enemy();
			plane_attack();
			add_boxes();
		}

		//player self group related
		createRocket();
		rotateRocket();

		for(var i = 0 ; i < ENEMY_KINDS ; i ++ ){
			if(weaponMode === BULLET) game.physics.arcade.overlap(bullets, enemys[i], enemyHit, null, this); // Bullets vs Enemys
			else if(weaponMode === RAY) game.physics.arcade.overlap(rays, enemys[i], rayenemyHit, null, this); // Rays vs Enemys
			else if(weaponMode === LIGHTNING){
				game.physics.arcade.overlap(lightnings, enemys[i], lightningenemyHit, null, this); // Lightnings vs Enemys
				for(var j = 0; j < ENEMY_BULLET_KINDS; j++){ // Lightnings vs Enemy Bullets
					game.physics.arcade.overlap(lightnings, enemyBullets[i], lightningBulletHit, null, this);
				}
			}
			if(FireballsExist === true){ // Fireballs exist
				var par = (game.time.now - fireballStartTime) / 1000 * Math.PI;
				for(var j = 0; j < MAX_FIREBALL; j++){
					Ball[j].position.x = player.position.x + FIREBALL_RADIUS * Math.sin(par + 2/MAX_FIREBALL * j * Math.PI);
					Ball[j].position.y = player.position.y + FIREBALL_RADIUS * Math.cos(par + 2/MAX_FIREBALL * j * Math.PI);
				}
				game.physics.arcade.overlap(fireballs, enemys[i], fireballenemyHit, null, this); // Fireballs vs Enemys
			}
			if(i != FORT) // player(on sky) cannot touch forts(on land)
				game.physics.arcade.overlap(player, enemys[i], playerHit, null, this); // Player vs Enemys
			game.physics.arcade.overlap(rocketPool, enemys[i], enemyHit, null, this); // Rockets vs Enemys
		}
		for(var i = 0; i < ENEMY_BULLET_KINDS; i++){ // Player vs Enemy Bullets
			game.physics.arcade.overlap(player, enemyBullets[i], playerHitByBullet, null, this);
		}
		game.physics.arcade.overlap(player, boxes, PlayerVsBox, null, this); // Player vs Boxes
	}else {
		// animate gameover Text to center
		if( gameOverText != null && gameOverText.alive )	{
			if( gameOverText.y < game.height/2 )
			 	gameOverText.y += 2*background_movement;
		}
	}
}

function listenSocket(){
	socket.on('setX', function(data) {
		newX = parseFloat(data);
	});
	socket.on('setY', function(data) {
		newY = parseFloat(data);
	});
	socket.on('ultra', function(data) {
		if(player.alive)
			launchult();
	});
	socket.on('start', function(data) {
		state = STARTGAME;
		if( !player.alive )	{
			setupPlayer(false);
			weaponLevel = 0;
			score = 0;
			resetPlayerLives();
			gameOverText.kill();
			scoreBoardText.kill();
		}
		resetMenu();
	});
	socket.on('shoot', function(data) {
		if(state === STARTGAME){
			game.time.events.add(Phaser.Timer.SECOND * ULT_FILL_TIME, fillult, this);
			levelup_loop = game.time.events.loop(Phaser.Timer.SECOND * LEVELUP_TIME, difficultyUP, this);
			state = INGAME;
			setupFireRate();
			gamestartMenu.kill();
			setPlayerSpawnTimeUndead(); // game start
		} else{
			fire();
		}
	});
	socket.on('switch_weapon', function(msg){
		 weaponMode = msg;
	});
	socket.on('scoreBoard', function(data)	{
		console.log('data = ' + data);
		scoreBoardText = game.add.bitmapText(game.width/2, game.height/2 + 32, 'minecraftia', data);
		scoreBoardText.anchor.setTo(0.5, 0.5);
	});
}

function updateText(){
	scoreText.text = 'Score: ' + score;
	ultText.text = 'ULT state: ' + ultstate[ult];
}

function difficultyUP(){
	DIFFICULTY++;
	DIFFICULTY_CHANGE = CHANGING;
	enemy_bullet_velocity[0] += 20;
	enemy_bullet_velocity[1] += 35;
	enemy_bullet_velocity[2] += 25;
	enemy_bullet_velocity[3] += 20;
	difficultyText = game.add.text(game.width/2, game.height/2, 'Difficulty: '+DIFFICULTY, { fontSize: '20px', fill: '#000' });
	difficultyText.anchor.setTo(0.5, 0.5);
	game.time.events.add(Phaser.Timer.SECOND * 5, difficultyTextDel, this);
}

function difficultyTextDel(){
	DIFFICULTY_CHANGE = NOCHANGE;
	difficultyText.kill();
}

function fire() {
	if(weaponMode === BULLET){
		if (player.alive && game.time.now > nextFire && bullets.countDead() > 0){
			if (this.bullets.countDead() < weaponLevel * 2) {
				return;
			}
			nextFire = game.time.now + fireRate;
			var bullet = bullets.getFirstDead();
			bullet.reset(player.x , player.y - 10);
			bullet.body.velocity.y = -player_bullet_velocity;

			for (var i = 1; i <= weaponLevel; i++) {
				bullet = bullets.getFirstExists(false);
				bullet.reset(player.x - i * 6, player.y - 10); // spawn left bullet slightly left off center
				game.physics.arcade.velocityFromAngle(
					-95 - i * 10, player_bullet_velocity, bullet.body.velocity
				); // the left bullets spread from -95 degrees to -135 degrees

				bullet = bullets.getFirstExists(false);
				bullet.reset(player.x + i * 6, player.y - 10); // spawn right bullet slightly right off center
				game.physics.arcade.velocityFromAngle(
					-85 + i * 10, player_bullet_velocity, bullet.body.velocity
				); // the right bullets spread from -85 degrees to -45
			}
		}
	}
	else if(weaponMode === RAY){
		if (player.alive && game.time.now > nextFire && rays.countDead() > 0){
			nextFire = game.time.now + rayfireRate;
			var ray = rays.getFirstDead();
			ray.reset(player.x , player.y - 10);
			ray.body.velocity.y = -player_bullet_velocity*5;
			ray.scale.setTo(1+0.5*weaponLevel,1);
		}
	}
	else if(weaponMode === LIGHTNING){
		if (player.alive && game.time.now > nextFire && lightnings.countDead() > 0){
			nextFire = game.time.now + lightningfireRate;
			var lightning = lightnings.getFirstDead();
			lightning.reset(player.x , 0);
			lightning.scale.setTo(1, 3.5);
			lightning.animations.add('lightning', [0,1,2,3,4,5], 6, true);
			lightning.play('lightning', 15, true, false);
			game.time.events.add(Phaser.Timer.SECOND * (6+weaponLevel), fadeLightning, this, lightning);
		}
	}
}

function fillult(){
	ult = FILLED;
	ultsign = game.add.sprite(16, 36, 'ultsign');
	ultText.fill = '#F00';
	socket.emit('ULT', 'filled');
}

function launchult(){
	if(ult === FILLED){
		ult = EMPTY;
		ultText.fill = '#000';
		ultsign.kill();
		for( var i = 0; i < ENEMY_KINDS; i++){
			enemys[i].forEachAlive(function (enemy) {
				explode(enemy);
				enemy.damage(ULT_DAMAGE);
				if( !enemy.alive ) score += 10;
				score += 10;
			}, this);
		}
		for( var i = 0; i < ENEMY_BULLET_KINDS; i++){
			enemyBullets[i].forEachAlive(function (bullet) {
				explode(bullet);
				bullet.kill();
			}, this);
		}
		game.time.events.add(Phaser.Timer.SECOND * 10, fillult, this);
	}
}

function add_boxes()	{
	if( game.time.now > nextBox && boxes.countDead() > 0 )	{
		nextBox = game.time.now + game.rnd.integerInRange(10000, 30000);
		var box = boxes.getFirstExists(false);
		box.reset(game.rnd.integerInRange(20, game.width - 20), 0); // spawn at a random location top of the screen
		box.scale.setTo(1.5, 1.5);
		var rnd = game.rnd.integerInRange(0, 7);
		if (rnd === 7)
			box.animations.add('box', [0,3,6,9,12,15,18,1,4,7,10,13,16,19,2,5,8,11,14,17,20], 21, true); //colorful box
		else
			box.animations.add('box', [rnd*3, rnd*3+1, rnd*3+2], 21, true); //single-color box
		box.play('box', 15, true, false);
		box.type = rnd;
		game.physics.arcade.velocityFromAngle(
			game.rnd.integerInRange(180, 360), 50, box.body.velocity
		); // also randomize the speed

		game.time.events.add(Phaser.Timer.SECOND * BOX_TIME, fadeBox, this, box);
	}
}

function fadeBox(box) {
	box.kill();
}

function fadeLightning(lightning) {
	lightning.kill();
}

function fadeFireball(fireball)	{
	FireballsExist = false;
	fireball.kill();
}

function resetFireballs(){
	for(var i = 0; i < MAX_FIREBALL; i ++){
		game.time.events.remove(fireballEvent[i]);
		Ball[i].kill();
	}
	FireballsExist = false;
}

function spawn_enemy() {

	if( !player.alive )
		return;

	if (game.time.now > nextEnemy[FORT] && enemys[FORT].countDead() > 0){ // Spawn forts
		nextEnemy[FORT] = game.time.now + game.rnd.integerInRange(10000, 10000);
		var enemy = enemys[FORT].getFirstExists(false);
		enemy.reset(game.rnd.integerInRange(20, game.width - 20), 0, FORT_HEALTH);
		enemy.enemyNextFire = 0;

		enemy.animations.add('open', [0, 1, 2, 3, 4, 5, 6, 7, 8, 8, 8, 8, 8, 8], 20, false);
		enemy.animations.add('close', [8, ,8 ,8 ,8, 8, 8, 7, 6, 5, 4, 3, 2, 1, 0], 20, false);
		enemy.loop = game.time.events.loop(Phaser.Timer.SECOND * 10, fort_attack, this, enemy);
	}
	if (game.time.now > nextEnemy[PLANE_SMALL] && enemys[PLANE_SMALL].countDead() > 0){ // Spawn small enemy plane
		nextEnemy[PLANE_SMALL] = game.time.now + game.rnd.integerInRange(1000, 3000);
		var enemy = enemys[PLANE_SMALL].getFirstExists(false);
		enemy.reset(game.rnd.integerInRange(20, game.width - 20), 0, PLANE_SMALL_HEALTH);
		enemy.body.velocity.y = game.rnd.integerInRange(30, 60);
		enemy.enemyNextFire = 0;
	}
	if (game.time.now > nextEnemy[PLANE_MEDIUM] && enemys[PLANE_MEDIUM].countDead() > 0){ // Spawn medium enemy plane
		nextEnemy[PLANE_MEDIUM] = game.time.now + game.rnd.integerInRange(2000, 4000);
		var enemy = enemys[PLANE_MEDIUM].getFirstExists(false);
		enemy.reset(game.rnd.integerInRange(20, game.width - 20), 0, PLANE_MEDIUM_HEALTH);
		var target = game.rnd.integerInRange(20, game.width - 20);
		enemy.rotation = game.physics.arcade.moveToXY(
			enemy, target, game.height,
			game.rnd.integerInRange(40, 80)
		) - Math.PI / 2;
		enemy.enemyNextFire = 0;
	}
	if (game.time.now > nextEnemy[PLANE_LARGE] && enemys[PLANE_LARGE].countDead() > 0){ // Spawn large enemy plane
		nextEnemy[PLANE_LARGE] = game.time.now + game.rnd.integerInRange(60000, 120000);
		var enemy = enemys[PLANE_LARGE].getFirstExists(false);
		enemy.reset(game.rnd.integerInRange(20, game.width - 20), 0, PLANE_LARGE_HEALTH);
		enemy.body.velocity.y = game.rnd.integerInRange(10, 20);
		enemy.enemyNextFire = 0;
	}
}

function fort_attack(enemy)	{
	if ( enemyBullets[FORT_BULLET].countDead() > 0 && enemy.alive ){
		enemy.play('open');
		for( var i = 0 ; i < FORT_BULLET_NUM; i ++ )	{
			//  left
			var enemy_bullet = enemyBullets[FORT_BULLET].getFirstDead();
			enemy_bullet.reset(enemy.x - i*30, enemy.y );
			enemy_bullet.body.velocity.x = -enemy_bullet_velocity[FORT];
			// right
			enemy_bullet = enemyBullets[FORT_BULLET].getFirstDead();
			enemy_bullet.reset(enemy.x + i*30, enemy.y );
			enemy_bullet.body.velocity.x = enemy_bullet_velocity[FORT];
			// bottom
			enemy_bullet = enemyBullets[FORT_BULLET].getFirstDead();
			enemy_bullet.reset(enemy.x, enemy.y + i*30);
			enemy_bullet.body.velocity.y = enemy_bullet_velocity[FORT];
			// top
			enemy_bullet = enemyBullets[FORT_BULLET].getFirstDead();
			enemy_bullet.reset(enemy.x, enemy.y - i*30);
			enemy_bullet.body.velocity.y = -enemy_bullet_velocity[FORT];
		}
		enemy.play('close');
	}else if( !enemy.alive ){
		game.time.events.remove(enemy.loop);
	}
}

function plane_attack() {

	if( !player.alive )
		return;

	enemys[PLANE_SMALL].forEachAlive(function (enemy) {
		if (game.time.now > enemy.enemyNextFire && enemyBullets[PLANE_SMALL_BULLET].countDead() > 0){
			enemy.enemyNextFire = game.time.now + game.rnd.integerInRange(1000, 3000);
			var enemy_bullet = enemyBullets[PLANE_SMALL_BULLET].getFirstDead();
			enemy_bullet.reset(enemy.x, enemy.y + enemy.height/2);
			enemy_bullet.body.velocity.y = enemy_bullet_velocity[PLANE_SMALL];
		}
	}, this);

	enemys[PLANE_MEDIUM].forEachAlive(function (enemy) {
		if (game.time.now > enemy.enemyNextFire && enemyBullets[PLANE_MEDIUM_BULLET].countDead() > 0){
			enemy.enemyNextFire = game.time.now + game.rnd.integerInRange(2000, 5000);
			var enemy_bullet = enemyBullets[PLANE_MEDIUM_BULLET].getFirstDead();
			enemy_bullet.reset(enemy.x, enemy.y + enemy.height/2);
			game.physics.arcade.moveToObject(enemy_bullet, player, enemy_bullet_velocity[PLANE_MEDIUM]);
		}
	}, this);

	enemys[PLANE_LARGE].forEachAlive(function (enemy) {
		if (game.time.now > enemy.enemyNextFire && enemyBullets[PLANE_LARGE_BULLET].countDead() > 0){
			enemy.enemyNextFire = game.time.now + game.rnd.integerInRange(5000, 6000);
			for( var i = 0 ; i < PLANE_LARGE_BULLET_NUM; i ++ )	{
				var enemy_bullet = enemyBullets[PLANE_LARGE_BULLET].getFirstDead();
				enemy_bullet.reset(enemy.x + 50, enemy.y + enemy.height/2 - i*30);
				game.physics.arcade.moveToObject(enemy_bullet, player, enemy_bullet_velocity[PLANE_LARGE]);
				enemy_bullet = enemyBullets[PLANE_LARGE_BULLET].getFirstDead();
				enemy_bullet.reset(enemy.x - 50, enemy.y + enemy.height/2 - i*30);
				game.physics.arcade.moveToObject(enemy_bullet, player, enemy_bullet_velocity[PLANE_LARGE]);
			}
		}
	}, this);
}

function createRocket()	{

	if (game.time.now > player.nextRocket && rocketPool.countDead() > 0){
		player.nextRocket = game.time.now + ROCKET_COOLDOWN;
		for( var i = 0 ; i <= weaponLevel/2 ; i ++ )	{
			var rocket = rocketPool.getFirstDead();
			rocket.reset(player.x + 50, player.y + player.height/2 );
			rocket.target = enemys[game.rnd.integerInRange(0, 3)].getFirstAlive();
			rocket.angle = 5 + i*20;
			game.physics.arcade.velocityFromAngle( -95 - i*20, rocket_velocity + 25*weaponLevel, rocket.body.velocity);

			rocket = rocketPool.getFirstDead();
			rocket.reset(player.x - 50, player.y + player.height/2 );
			rocket.target = enemys[game.rnd.integerInRange(0, 3)].getFirstAlive();
			rocket.angle = -5 - i*20;
			game.physics.arcade.velocityFromAngle( -85 + i*20, rocket_velocity + 25*weaponLevel, rocket.body.velocity);
		}
	}
}

function rotateRocket()	{
	rocketPool.forEachAlive(function(rocket)	{
		if( rocket.target != null && rocket.target.alive )	{
			var radians = game.physics.arcade.angleBetween(rocket, rocket.target);
			degrees = radians * (180/Math.PI);
			game.physics.arcade.velocityFromAngle(degrees, rocket_velocity + 25*weaponLevel, rocket.body.velocity);
			rocket.angle = degrees+90;
		}else {
			// velocity along original
		}
	}, this);
}

function enemyHit(bullet, enemy) {
	bullet.kill();
	enemy.damage(1);
	//if (enemy.alive) play hit animation(not available yet) else play explode animation
	explode(enemy);
	score += 10;
}

function rayenemyHit(bullet, enemy) {
	enemy.damage(1);
	//if (enemy.alive) play hit animation(not available yet) else play explode animation
	explode(enemy);
	score += 10;
}

function lightningenemyHit(lightning, enemy) {
	enemy.damage(1);
	//if (enemy.alive) play hit animation(not available yet) else play explode animation
	explode(enemy);
	score += 10;
}

function fireballenemyHit(fireball, enemy) {
	enemy.damage(1);
	//if (enemy.alive) play hit animation(not available yet) else play explode animation
	explode(enemy);
	score += 10;
}

function lightningBulletHit(lightning, bullet) {
	explode(bullet);
	bullet.kill();
	score += 5;
}

function playerHit(player, enemy) {
	if (playerSpawnUndead === true) {
		return;
	}
	else if (playerSuper === true) {
		explode(enemy);
		enemy.kill();
		score += 10;
		return;
	}
	explode(enemy);
	explode(player);
	enemy.kill();
	game.time.events.remove(player.shield.loop);

	var life = lives.getFirstAlive();
	if (life !== null) {
		life.kill();
		socket.emit('vibrate', 'hit');
		setPlayerSpawnTimeUndead();
		player.reset(game.width / 2, game.height - 50);
	} else {
		player.kill();
		player.shield.kill();
		if(FireballsExist === true)
			resetFireballs();
		socket.emit('vibrate', 'die');
		gameOver();
		// clear all
		launchult();
	}
}

function playerHitByBullet(player, bullet) {
	if (playerSpawnUndead === true) {
		return;
	}
	else if (playerSuper === true) {
		bullet.kill();
		return;
	}
	explode(player);
	bullet.kill();
	game.time.events.remove(player.shield.loop);

	var life = lives.getFirstAlive();
	if (life !== null) {
		life.kill();
		socket.emit('vibrate', 'hit');
		setPlayerSpawnTimeUndead();
		player.reset(game.width / 2, game.height - 50);
	} else {
		player.kill();
		player.shield.kill();
		if(FireballsExist === true)
			resetFireballs();
		socket.emit('vibrate', 'die');
		gameOver();
		launchult();
	}
}

function PlayerVsBox(player, box)	{
	switch(box.type)	{
		case yellow:
			FireBallSurround(player);
			weaponLevel--
			break;
		case orange:
			weaponLevel--;
			heal();
			break;
		case green:
			weaponLevel--;
			if(fireRate>100){
				fireRate-=25;
				rayfireRate-=100;
				lightningfireRate-=250;
			}
			break;
		case chocolate:
			break;
		case blue:
			break;
		case dark_blue:
			break;
		case gray:
			break;
		case colorful:
			superPlayer();
			break;
	}
			superPlayer();

	box.kill();
	score += 50;
	if( weaponLevel < MAX_WEAPON_LEVEL )
		weaponLevel ++;
}

function heal()	{
	var dead_lives = lives.countDead();
	if( dead_lives > 0 ) 	{
		var newlife = lives.getChildAt(dead_lives-1);
		newlife.reset(this.game.width - 10 - (MAX_LIFE * 30) + 30*(dead_lives-1) , 30);
	}
}

function superPlayer(){
// When got a colorful box, the player can become undead and kill the enemies (except turrets) with bumping
	if(playerSuper === true){
		game.time.events.remove(superEvent);
	} else{	
		tmptint = player.tint;
		player.alpha = 1;
		tweenPlayer.stop();
		playerSuper = true;
		playerSpawnUndead = false;
		var startTime = Date.now();	
		for(var i = 0; i < 6; i++){
			superTween[i] = game.add.tween(player).to({ tint: tints[i] }, 200, Phaser.Easing.Linear.None, false, 0, 1, false);
		}
		for(var i = 0; i < 6; i++){
			superTween[i].chain(superTween[(i+1)%6]);
		}
		superTween[0].start();
	}
	superEvent = game.time.events.add(playerSuperTime, function(){
		for(var i = 0; i < 6; i++){
			superTween[i].stop();
		}
		player.tint = tmptint;
		playerSuper = false;
	}, this);
}


function swap(){
	if(weaponMode===BULLET) weaponMode=LIGHTNING;
	else if(weaponMode===LIGHTNING) weaponMode=RAY;
	else weaponMode=BULLET;
}

function FireBallSurround(sprite){
	if (fireballs.countDead() === 0) {
		for(var i = 0; i < MAX_FIREBALL; i++){
			game.time.events.remove(fireballEvent[i]);
			fireballEvent[i] = game.time.events.add(Phaser.Timer.SECOND * FIREBALL_TIME, fadeFireball, this, Ball[i]);
		}
		return;
	}

	FireballsExist=true;
	fireballStartTime = game.time.now;
	for(var i = 0; i < MAX_FIREBALL; i++){
		Ball[i] = fireballs.getFirstDead();
		Ball[i].reset(sprite.x, sprite.y);
		Ball[i].animations.add('flame', [0,1,2], 3, true);
		Ball[i].play('flame', 15, true, false);
		fireballEvent[i] = game.time.events.add(Phaser.Timer.SECOND * FIREBALL_TIME, fadeFireball, this, Ball[i]);
	}
}

function explode(sprite) {
	if (explosionPool.countDead() === 0) {
		return;
	}
	var explosion = explosionPool.getFirstExists(false);
	explosion.reset(sprite.x, sprite.y);
	explosion.play('boom', 15, false, true);
	explosion.body.velocity.x = sprite.body.velocity.x;
	explosion.body.velocity.y = sprite.body.velocity.y;
}

function gameOver(){
	state = ENDGAME;
	DIFFICULTY = 1;
	game.time.events.remove(levelup_loop);
	if( difficultyText != null )
		difficultyTextDel();
	gameOverText = game.add.text(game.width/2, 0, 'Game Over!', { font: '32px sans-serif', fill: '#fff'});
	gameOverText.anchor.setTo(0.5, 0.5);

	//initialize velocity
	enemy_bullet_velocity = [200, 350, 250, 200];

	// save to DB
	var user = {name: "treetreeTest", score: parseInt(score), time: Date.now()};
	socket.emit("data", user);

}

function setupBackground(){
	game.physics.startSystem(Phaser.Physics.ARCADE);

	// Stretch to fill
	//game.scale.fullScreenScaleMode = Phaser.ScaleManager.EXACT_FIT;
	background = game.add.tileSprite(0, 0, window.innerWidth, window.innerHeight, 'sky');
	background.tileScale.x = window.innerWidth/background.width;
	background.tileScale.y = window.innerHeight/background.height;
}

function setupPlayer(isSetSpawnTimeUndead){
// Parameter: isSetSpawnTimeUndead (default = true): The player will be undead after spawn time for "playerSpawnUndeadTime" milliseconds if this is true

	isSetSpawnTimeUndead = typeof isSetSpawnTimeUndead !== 'undefined' ? isSetSpawnTimeUndead : true;

	player = game.add.sprite(game.width / 2, game.height - 50, 'player');
	game.physics.arcade.enable(player);
	player.body.collideWorldBounds = true;
	player.anchor.x = 0.5;
	player.anchor.y = 0.5;

	player.scale.setTo(1.5, 1.5);

	// shield
	player.shield = game.add.sprite(player.x, player.y, 'shield');
	game.physics.arcade.enable(player.shield);
	player.shield.anchor.x = 0.5;
	player.shield.anchor.y = 0.5;
	player.shield.animations.add('effect', [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19], 20, true);
	player.shield.animations.play('effect');
	player.shield.loop = game.time.events.loop(Phaser.Timer.SECOND * 3, function()	{
		player.shield.animations.play('effect');
	}, this);

	player.nextRocket = 0; 	// Rocket related

	//player.addChild(shield);

	if (isSetSpawnTimeUndead === true)
		setPlayerSpawnTimeUndead();
}

function setPlayerSpawnTimeUndead(){
	player.alpha = 1;
	playerSpawnUndead = true;
	tweenPlayer = game.add.tween(player).to( { alpha: 0.5 }, 200, Phaser.Easing.Linear.None, true, 0, playerSpawnUndeadTime / (200 * 2), true);
	game.time.events.add(playerSpawnUndeadTime, function(){
		player.alpha = 1;
		tweenPlayer.stop();
		playerSpawnUndead = false;
	}, this);
}

function setupBullets(){
	bullets = game.add.group();
	bullets.enableBody = true;
	bullets.physicsBodyType = Phaser.Physics.ARCADE;
	bullets.createMultiple(weapon_num[BULLET], 'bullet');
	bullets.setAll('checkWorldBounds', true);
	bullets.setAll('outOfBoundsKill', true);
}

function setupRays(){
	rays = game.add.group();
	rays.enableBody = true;
	rays.physicsBodyType = Phaser.Physics.ARCADE;
	rays.createMultiple(weapon_num[RAY], 'ray');
	rays.setAll('checkWorldBounds', true);
	rays.setAll('outOfBoundsKill', true);
	rays.setAll('anchor.x', 0.5);
	rays.setAll('anchor.y', 0.8);
}

function setupLightnings(){
	lightnings = game.add.group();
	lightnings.enableBody = true;
	lightnings.physicsBodyType = Phaser.Physics.ARCADE;
	lightnings.createMultiple(weapon_num[LIGHTNING], 'lightning');
	lightnings.setAll('anchor.x', 0.5);
}

function setupFireRate(){
	fireRate = 200;
	rayfireRate = 500;
	lightningfireRate = 2000;
}

function setupFireBalls(){
	fireballs = game.add.group();
	fireballs.enableBody = true;
	fireballs.physicsBodyType = Phaser.Physics.ARCADE;
	fireballs.createMultiple(MAX_FIREBALL, 'fireball');
	fireballs.setAll('anchor.x', 0.5);
	fireballs.setAll('anchor.y', 0.5);
	fireballs.setAll('scale.x', 0.8);
	fireballs.setAll('scale.y', 0.8);
}

function setupEnemys(){
	for(var i = 0 ; i < ENEMY_KINDS; i++){
		enemys[i] = game.add.group();
		enemys[i].enableBody = true;
		enemys[i].physicsBodyType = Phaser.Physics.ARCADE;
		enemys[i].createMultiple(enemy_num[i], 'enemy'+i);
		enemys[i].setAll('checkWorldBounds', true);
		enemys[i].setAll('outOfBoundsKill', true);
		enemys[i].setAll('anchor.x', 0.5);
		enemys[i].setAll('anchor.y', 0.5);
		enemys[i].setAll('scale.x', (i == 3) ? 3 : 1.5);
		enemys[i].setAll('scale.y', (i == 3) ? 3 : 1.5);

		enemys[i].forEach(function(enemy)	{
			enemy.body.width *= enemy.scale.x;
			enemy.body.height *= enemy.scale.y;
		});
	}
}

function setupEnemyBullets(){
	for( var i = 0; i < ENEMY_BULLET_KINDS; i++){
		enemyBullets[i] = game.add.group();
		enemyBullets[i].enableBody = true;
		enemyBullets[i].physicsBodyType = Phaser.Physics.ARCADE;
		enemyBullets[i].createMultiple(enemyBullet_num[i], 'enemy_bullet' + (i+1) );
		enemyBullets[i].setAll('checkWorldBounds', true);
		enemyBullets[i].setAll('outOfBoundsKill', true);
		enemyBullets[i].setAll('scale.x', 1.5);
		enemyBullets[i].setAll('scale.y', 1.5);
	}
}

function setupPlayerLives(){
	lives = game.add.group();
	var firstLifeIconX = this.game.width - 10 - (MAX_LIFE * 30);
	for (var i = 0; i < MAX_LIFE; i++) {
		var lifeIcon = this.lives.create(firstLifeIconX + (30 * i), 30, 'player');
		lifeIcon.scale.setTo(0.8, 0.8);
		lifeIcon.anchor.setTo(0.5, 0.5);
	}
}

function resetPlayerLives(){
	var firstLifeIconX = this.game.width - 10 - (MAX_LIFE * 30);
	for (var i = 0; i < MAX_LIFE; i++) {
		var lifeIcon = this.lives.create(firstLifeIconX + (30 * i), 30, 'player');
		lifeIcon.scale.setTo(0.8, 0.8);
		lifeIcon.anchor.setTo(0.5, 0.5);
	}
}

function setupBoxes() {
	boxes = game.add.group();
	boxes.enableBody = true;
	boxes.physicsBodyType = Phaser.Physics.ARCADE;
	boxes.createMultiple(MAX_BOXES, 'bonus_cube');
	boxes.setAll('body.collideWorldBounds', true);
	boxes.setAll('outOfBoundsKill', true);
	boxes.setAll('body.bounce.x', 1);
	boxes.setAll('body.bounce.y', 1);
}

function setupExplosions() {
	explosionPool = game.add.group();
	explosionPool.enableBody = true;
	explosionPool.physicsBodyType = Phaser.Physics.ARCADE;
	explosionPool.createMultiple(MAX_EXPLOSION, 'explosion');
	explosionPool.setAll('anchor.x', 0.5);
	explosionPool.setAll('anchor.y', 0.5);
	explosionPool.setAll('scale.x', 1.5);
	explosionPool.setAll('scale.y', 1.5);
	explosionPool.forEach(function (explosion) {
		explosion.animations.add('boom');
	});
}

function setupMenu(){
	gamestartMenu = game.add.sprite(game.width/2, game.height / 2, 'gamestartMenu');
	gamestartMenu.anchor.setTo(0.5, 0.5);
}

function resetMenu(){
	gamestartMenu.reset(game.width/2, game.height / 2);
}

function setupULT(){
	ultsign_g = game.add.sprite(16, 36, 'ultsign_g');
}

function setupRocket()	{
	rocketPool = game.add.group();
	rocketPool.enableBody = true;
	rocketPool.physicsBodyType = Phaser.Physics.ARCADE;

	rocketPool.createMultiple(MAX_ROCKETS, 'rocket');
	rocketPool.setAll('checkWorldBounds', true);
	rocketPool.setAll('outOfBoundsKill', true);
	rocketPool.setAll('anchor.x', 0.5);
	rocketPool.setAll('anchor.y', 0.5);
	rocketPool.setAll('scale.x', 0.75);
	rocketPool.setAll('scale.y', 0.75);

	 rocketPool.forEach(function(rocket)	{
	 	//rocket.animations.add('rotate', [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], 15);
		// select the up arrow
	 	rocket.frame = 42;
	 });
}

</script>
</body>
</html>
